#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use Cwd;
use FindBin qw($Bin);
$|++;

my $help;
my $gc;
my $mink;
my $maxk;
my $maxseq;
my $outfile;
my $bg_option;
my $save_background;


unless (
		GetOptions (
				"help" => \$help,
				"gc=i"   => \$gc,
				"mink=i"  => \$mink,
				"maxk=i" => \$maxk,
				"maxseq=i" => \$maxseq,
				"outfile=s" => \$outfile,
				"background=s" => \$bg_option,
				"save_background=s" => \$save_background,
		)
		) {die "Failed to parse options\n";}

if ($help) {
		print while (<DATA>);
		exit;
}

my @files = @ARGV;

unless ($outfile and @files) {
		die "Usage is compter --outfile [outfile] [fasta_file1].. [fastq_file_x]\nRun comter --help for more options\n";
}

check_arguments();
my $background = make_background();

open (OUT, '>', $outfile) or die "Failed to write to '$outfile': $!";

# Write the header first...

my @kmer_names = sort keys %$background;

print OUT join("\t",("Sequence","File",@kmer_names)),"\n";


foreach my $file (@files) {
		process_file ($file);
}


close OUT or die "Couldn't write to $outfile: $!";

draw_heatmap($outfile);

sub draw_heatmap {
		
		my ($infile) = @_;
		my $dir = getcwd;
		my $outfile = $infile;
		$outfile =~ s/\.txt$//;
		$outfile .= ".png";


		my $r_script = <<"END_SCRIPT";
directory <- "$dir"
file <- "$infile"
outfile <- "$outfile"

setwd(directory)
library(pheatmap)

read.delim(file,check.names=FALSE, stringsAsFactors=FALSE) -> compter.data

compter.data[[2]] -> group.names


as.data.frame(t(compter.data[,3:ncol(compter.data)])) -> compter.data
data.frame(Var1=group.names) -> group.annotation
rownames(group.annotation) <- colnames(compter.data)

max.value = max(compter.data)
min.value = min(0-compter.data)

if (max.value > min.value) {
  max.value = min.value
  min.value = 0-min.value
} else {
  min.value = 0-max.value
}

png(filename = outfile,width = 900, height = 900)
pheatmap(compter.data,
         annotation=group.annotation,
         show_colnames=FALSE,
         main=file,
         breaks=seq(from=min.value,to=max.value,length.out=50),
         color=colorRampPalette(c("magenta","white","green"))(50),
         border.color = NA)
dev.off()

END_SCRIPT

open (IN, "| R --no-save") or die "Can't open pipe to R";

		print IN $r_script;

		close IN or die "Can't write to R pipe";


}



sub process_file {

		my ($file) = @_;

		warn "Processing $file\n";
		
		my @seqdata;
		my @seqnames;

		my $id;
		my $seq;

		open (IN,$file) or die "Can't read $file: $!";

		my $count = 0;

		while (<IN>) {

				if (/>(\S+)/) {
						my $next_name = $1;
						if ($seq) {
								++$count;

								if ($count % 100 == 0) {
										print ".";
								}

								if ($count == $maxseq) {
										warn "Reached maxseq limit of $maxseq: stopping early\n";
										last;
								}

								if (length($seq) < $maxk) {
										warn "Skipping $id in $file as it's too short (".length($seq).")\n";
								}

								else {
										push @seqdata,calculate_enrichment($seq);
										push @seqnames,$id;
								}
						}
						$seq = "";
						$id = $next_name;
				}
				else {
						s/[\r\n]//g;
						next unless ($_);

						$seq .= uc($_);
				}				
		}

		if ($seq) {
				if (length($seq) < $maxk) {
						warn "Skipping $id in $file as it's too short (".length($seq).")\n";
				}

				else {
						push @seqdata,calculate_enrichment($seq);
						push @seqnames,$id;
				}
		}

		close IN;

		my @kmer_names = sort keys %$background;

		foreach my $sample_index (0..$#seqnames) {
				my @line = ($seqnames[$sample_index],$file);

				my $sample = $seqdata[$sample_index];

				foreach my $index (0..$#kmer_names) {
						push @line,$sample->[$index];
				}

				print OUT join("\t",@line),"\n";
		}


}

sub get_observed_kmers {
		my ($seq,$min,$max) = @_;

		my %observed;

		for my $size ($min..$max) {
				foreach my $start (0..(length($seq)-($size+1))) {
						my $kseq = substr($seq,$start,$size);
						++$observed{$kseq};
				}
		}

		return %observed;
}

sub get_valid_kmers {
		my @kmers = sort keys %$background;

		my @valid;

		foreach my $kmer (@kmers) {
				if (length($kmer) >= $mink and length($kmer) <= $maxk) {
						push @valid,$kmer;
				}

		}

		return @valid;

}

sub calculate_enrichment {

		my ($seq) = @_;

		my @kmers = get_valid_kmers();

		my %raw_observed = get_observed_kmers($seq,$mink,$maxk);

		my %counts_per_size;

		my %observed;

		foreach my $kmer (@kmers) {
				$observed{$kmer} = 0;
		}

		foreach my $kmer (keys %raw_observed) {
				next unless (exists $observed{$kmer});
				$observed{$kmer} = $raw_observed{$kmer};
				$counts_per_size{length{$kmer}} += $raw_observed{$kmer};
		}

		my @enrichments;
		
		foreach my $kmer (@kmers) {
				my $freq = $observed{$kmer} / $counts_per_size{length($kmer)};
				if ($freq == 0) {
						$freq = 0.5 / $counts_per_size{length($kmer)};
				}
				my $enrichment = log($freq/$background->{$kmer})/log(2);
				push @enrichments,$enrichment;
		}
		
		return \@enrichments;

}


sub check_arguments {
    # Check GC settings
		if ($gc) {
				unless ($gc =~ /^\d+$/) {
						die "GC value $gc wasn't an integer";
				}

				if ($gc < 20 or $gc > 80) {
						die "GC must be in the range 20-80%";
				}
		}
		else {
				$gc = 50;
		}

    # Check kmer range
		if ($mink) {
				unless ($mink =~ /^\d+$/) {
						die "MinK $mink wasn't an integer";
				}
				if ($mink < 1 or $mink > 3) {
						die "MinK must be in the range 1-3%";
				}
		}
		else {
				$mink = 1;
		}

		if ($maxk) {
				unless ($maxk =~ /^\d+$/) {
						die "Maxk $maxk wasn't an integer";
				}
				if ($maxk < 1 or $maxk > 3) {
						die "Maxk must be in the range 1-3%";
				}
		}
		else {
				$maxk = 3
		}
		
		if ($maxk < $mink) {
				die "MaxK value ($maxk) was lower than MinK value ($mink)\n";
		}

		# Maxseq
		if ($maxseq) {
				unless ($maxseq =~ /^\d+$/) {
						die "Maxseq $maxseq wasn't an integer";
				}
				if ($maxseq < 1) {
						die "Maxk must be 1 or more";
				}
		}
		else {
				$maxseq = 1000;
		}
		

		# Outfile
		unless ($outfile) {
				die "Output file (--outfile) wasn't specified\n";
		}

}

sub make_background {

		# We do different things depending on what type of background we're making

		if ($bg_option) {
				# The background can be one of 3 different things
				# 1) A fasta file to compute the background from
				# 2) A pre-calculated compter file
				# 3) The name of a pre-calculated background which exists in the backgrounds folder

				if ($bg_option =~ /\.cmp$/) {
						# It's a compter file
						_make_compter_background($bg_option);
				}
				elsif (-e "$Bin/backgrounds/${background}.cmp") {
						# It's a pre-calculated background
						return(_make_compter_background("$Bin/backgrounds/${background}.cmp"));
				}
				elsif (-e $bg_option) {
						# We assume it's a fasta file
						return(_make_fasta_background($bg_option))
				}
				else {
						die "Couldn't figure out how to make a background from '$bg_option'";
				}

		}

		else {
				return(_make_gc_background());
		}

}

sub _make_fasta_background {

		my ($file) = @_;

		my $min_used_length = $mink;
		my $max_used_length = $maxk;


		# If we're saving this we need to calculate the full range
		# we'll ever use - even if we're not using it this time.
		if ($save_background) {
				$min_used_length = 1;
				$max_used_length = 3;
		}


		my %kmer_counts;
		my %counts_per_length;

		my @letters = qw(G A T C);

		for my $kmer ($min_used_length..$max_used_length) {
#				warn "Looking at kmer length $kmer\n";
				my @kmers = @letters;
				for (0..($kmer-2)) {
						my @expanded;
						foreach my $existing (@kmers) {
								foreach my $letter (@letters) {
										push @expanded,"$existing$letter";
								}
						}
						@kmers = @expanded;
				}

				foreach my $kmer (@kmers) {
						$kmer_counts{$kmer} = 0;
				}
		}


		# Now we can read the file and calculate the frequencies
		# of the kmers within it

		open (my $SEQ,$file) or die "Can't read sequence file '$file': $!";

		my $seq;
		while (<$SEQ>) {
				s/[\r\n\s]//g;
				if (/^>/) {
						# We're at the start of a new sequence
						if ($seq) {
								my %k = get_observed_kmers($seq,$min_used_length,$max_used_length);

								foreach my $kmer (keys %k) {
										if (exists $kmer_counts{$kmer}) {
												$kmer_counts{$kmer} += $k{$kmer};
												$counts_per_length{length($kmer)} += $k{$kmer};
										}
								}
								$seq = "";
						}
				}
				else {
						$seq .= $_;
				}
		}

		close $SEQ;

		# Process the last sequence
		my %k = get_observed_kmers($seq,$min_used_length,$max_used_length);

		foreach my $kmer (keys %k) {
				if (exists $kmer_counts{$kmer}) {
						$kmer_counts{$kmer} += $k{$kmer};
						$counts_per_length{length($kmer)} += $k{$kmer};
				}
		}

		# Change the absolute values into frequencies

		foreach my $kmer (keys %kmer_counts) {

				$kmer_counts{$kmer} /= $counts_per_length{length($kmer)};

		}

		# Save the file if we need to
		if ($save_background) {
				open (my $BG,'>',$save_background) or die "Can't write to '$save_background': $!";

				foreach my $kmer (sort keys %kmer_counts) {
						print $BG join("\t",$kmer,$kmer_counts{$kmer}),"\n";
				}

		}

		return \%kmer_counts;


}

sub _make_compter_background {

		my ($file) = @_;


		# A compter background file is simply a 2 column delimited file
		# of kmer vs frequency.  We need to keep a record of the range of
		# lengths that we've seen to ensure that we've covered what we
		# need for the analysis.

		my $min_length_seen;
		my $max_length_seen;

		open (my $COM, $file) or die "Can't read '$file': $!";

		my %freqs;

		while (<IN>) {
				s/[\r\n]//g;

				my ($kmer,$freq) = split(/\t/);

				my $length = length($kmer);

				unless (defined $min_length_seen) {
						$min_length_seen = $length;
						$max_length_seen = $length;
				}

				$max_length_seen = $length if ($length > $max_length_seen);
				$min_length_seen = $length if ($length < $min_length_seen);

				if (exists $freqs{$kmer}) {
						die "Duplicate frequency found in '$file' for '$kmer'";
				}

				$freqs{$kmer} = $freq;

		}

		close $COM;

		die "Background provided doesn't cover length '$mink'" if ($min_length_seen > $mink);
		die "Background provided doesn't cover length '$maxk'" if ($max_length_seen < $maxk);

		return \%freqs;
}


sub _make_gc_background {

		my %freqs;

		my @letters = qw(G A T C);

		for my $kmer ($mink..$maxk) {
#				warn "Looking at kmer length $kmer\n";
				my @kmers = @letters;
				for (0..($kmer-2)) {
						my @expanded;
						foreach my $existing (@kmers) {
								foreach my $letter (@letters) {
										push @expanded,"$existing$letter";
								}
						}
						@kmers = @expanded;
				}

				foreach my $kmer (@kmers) {
						my $freq = 1;
						my @letters = split(//,$kmer);
						foreach my $letter (@letters) {
								if ($letter eq 'C' or $letter eq 'G') {
										$freq *= ($gc/2/100);
								}
								else {
										$freq *= ((100-$gc)/2/100);
								}
						}

						$freqs{$kmer} = $freq;

#						warn "Frequency of $kmer is $freq\n";
				}

		}

		return \%freqs;

}




__DATA__

    COMPTER - Comparative visualisation of sequence composition

PURPOSE
-------
Compter is a program which takes in one or more multi-fasta format DNA
sequence files and produces both text and graphical outputs summarising
the contents of the files.  It can be used to look for overall compositional
differences between samples, or to look for compositional sub-groups within
a single sequence set.

USAGE
-----

compter [options] [file1] [file2] [file n]



