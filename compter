#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use Cwd;
use FindBin qw($Bin);
$|++;

my $help;
my $gc;
my $mink;
my $maxk;
my $maxseq;
my $outfile;
my $bg_option;
my $save_background;


unless (
		GetOptions (
				"help" => \$help,
				"gc=i"   => \$gc,
				"mink=i"  => \$mink,
				"maxk=i" => \$maxk,
				"maxseq=i" => \$maxseq,
				"outfile=s" => \$outfile,
				"background=s" => \$bg_option,
				"savebg=s" => \$save_background,
		)
		) {die "Failed to parse options\n";}

if ($help) {
		print while (<DATA>);
		exit;
}

my @files = @ARGV;

unless ($outfile and @files) {
		die "Usage is compter --outfile [outfile] [fasta_file1].. [fastq_file_x]\nRun comter --help for more options\n";
}

check_arguments();
my $background = make_background();

open (OUT, '>', $outfile) or die "Failed to write to '$outfile': $!";

# Write the header first...

my @kmer_names = sort keys %$background;

print OUT join("\t",("Sequence","File",@kmer_names)),"\n";


foreach my $file (@files) {
		process_file ($file);
}


close OUT or die "Couldn't write to $outfile: $!";

draw_heatmap($outfile);

sub draw_heatmap {
		
		my ($infile) = @_;
		my $dir = getcwd;
		my $outfile = $infile;
		$outfile =~ s/\.txt$//;
		$outfile .= ".png";


		my $r_script = <<"END_SCRIPT";
directory <- "$dir"
file <- "$infile"
outfile <- "$outfile"

setwd(directory)
library(pheatmap)

read.delim(file,check.names=FALSE, stringsAsFactors=FALSE) -> compter.data

compter.data[[2]] -> group.names


as.data.frame(t(compter.data[,3:ncol(compter.data)])) -> compter.data
data.frame(Var1=group.names) -> group.annotation
rownames(group.annotation) <- colnames(compter.data)

max.value = max(compter.data)
min.value = min(0-compter.data)

if (max.value > min.value) {
  max.value = min.value
  min.value = 0-min.value
} else {
  min.value = 0-max.value
}

png(filename = outfile,width = 900, height = 900)
pheatmap(compter.data,
         annotation=group.annotation,
         show_colnames=FALSE,
         main=file,
         breaks=seq(from=min.value,to=max.value,length.out=50),
         color=colorRampPalette(c("magenta","white","green"))(50),
         border.color = NA)
dev.off()

END_SCRIPT

open (IN, "| R --no-save") or die "Can't open pipe to R";

		print IN $r_script;

		close IN or die "Can't write to R pipe";


}



sub process_file {

		my ($file) = @_;

		warn "Processing $file\n";
		
		my @seqdata;
		my @seqnames;

		my $id;
		my $seq;

		open (IN,$file) or die "Can't read $file: $!";

		my $count = 0;

		while (<IN>) {

				if (/>(\S+)/) {
						my $next_name = $1;
						if ($seq) {
								++$count;

								if ($count % 100 == 0) {
										print ".";
								}

								if ($count == $maxseq) {
										warn "Reached maxseq limit of $maxseq: stopping early\n";
										last;
								}

								if (length($seq) < $maxk) {
										warn "Skipping $id in $file as it's too short (".length($seq).")\n";
								}

								else {
										push @seqdata,calculate_enrichment($seq);
										push @seqnames,$id;
								}
						}
						$seq = "";
						$id = $next_name;
				}
				else {
						s/[\r\n]//g;
						next unless ($_);

						$seq .= uc($_);
				}				
		}

		if ($seq) {
				if (length($seq) < $maxk) {
						warn "Skipping $id in $file as it's too short (".length($seq).")\n";
				}

				else {
						push @seqdata,calculate_enrichment($seq);
						push @seqnames,$id;
				}
		}

		close IN;

		my @kmer_names = sort keys %$background;

		foreach my $sample_index (0..$#seqnames) {
				my @line = ($seqnames[$sample_index],$file);

				my $sample = $seqdata[$sample_index];

				foreach my $index (0..$#kmer_names) {
						push @line,$sample->[$index];
				}

				print OUT join("\t",@line),"\n";
		}


}

sub get_observed_kmers {
		my ($seq,$min,$max) = @_;

		my %observed;

		for my $size ($min..$max) {
				foreach my $start (0..(length($seq)-($size+1))) {
						my $kseq = substr($seq,$start,$size);
						++$observed{$kseq};
				}
		}

		return %observed;
}

sub get_valid_kmers {
		my @kmers = sort keys %$background;

		my @valid;

		foreach my $kmer (@kmers) {
				if (length($kmer) >= $mink and length($kmer) <= $maxk) {
						push @valid,$kmer;
				}

		}

		return @valid;

}

sub calculate_enrichment {

		my ($seq) = @_;

		my @kmers = get_valid_kmers();

		my %raw_observed = get_observed_kmers($seq,$mink,$maxk);

		my %counts_per_size;

		my %observed;

		foreach my $kmer (@kmers) {
				$observed{$kmer} = 0;
		}

		foreach my $kmer (keys %raw_observed) {
				next unless (exists $observed{$kmer});
				$observed{$kmer} = $raw_observed{$kmer};
				$counts_per_size{length{$kmer}} += $raw_observed{$kmer};
		}

		my @enrichments;
		
		foreach my $kmer (@kmers) {
				my $freq = $observed{$kmer} / $counts_per_size{length($kmer)};
				if ($freq == 0) {
						$freq = 0.5 / $counts_per_size{length($kmer)};
				}
				my $enrichment = log($freq/$background->{$kmer})/log(2);
				push @enrichments,$enrichment;
		}
		
		return \@enrichments;

}


sub check_arguments {
    # Check GC settings
		if ($gc) {
				unless ($gc =~ /^\d+$/) {
						die "GC value $gc wasn't an integer";
				}

				if ($gc < 20 or $gc > 80) {
						die "GC must be in the range 20-80%";
				}
		}
		else {
				$gc = 50;
		}

    # Check kmer range
		if ($mink) {
				unless ($mink =~ /^\d+$/) {
						die "MinK $mink wasn't an integer";
				}
				if ($mink < 1 or $mink > 3) {
						die "MinK must be in the range 1-3%";
				}
		}
		else {
				$mink = 1;
		}

		if ($maxk) {
				unless ($maxk =~ /^\d+$/) {
						die "Maxk $maxk wasn't an integer";
				}
				if ($maxk < 1 or $maxk > 3) {
						die "Maxk must be in the range 1-3%";
				}
		}
		else {
				$maxk = 3
		}
		
		if ($maxk < $mink) {
				die "MaxK value ($maxk) was lower than MinK value ($mink)\n";
		}

		# Maxseq
		if ($maxseq) {
				unless ($maxseq =~ /^\d+$/) {
						die "Maxseq $maxseq wasn't an integer";
				}
				if ($maxseq < 1) {
						die "Maxk must be 1 or more";
				}
		}
		else {
				$maxseq = 1000;
		}
		

		# Outfile
		unless ($outfile) {
				die "Output file (--outfile) wasn't specified\n";
		}

}

sub make_background {

		# We do different things depending on what type of background we're making

		if ($bg_option) {
				# The background can be one of 3 different things
				# 1) A fasta file to compute the background from
				# 2) A pre-calculated compter file
				# 3) The name of a pre-calculated background which exists in the backgrounds folder

				if ($bg_option =~ /\.cmp$/) {
						# It's a compter file
						_make_compter_background($bg_option);
				}
				elsif (-e "$Bin/backgrounds/${background}.cmp") {
						# It's a pre-calculated background
						return(_make_compter_background("$Bin/backgrounds/${background}.cmp"));
				}
				elsif (-e $bg_option) {
						# We assume it's a fasta file
						return(_make_fasta_background($bg_option))
				}
				else {
						die "Couldn't figure out how to make a background from '$bg_option'";
				}

		}

		else {
				return(_make_gc_background());
		}

}

sub _make_fasta_background {

		my ($file) = @_;

		my $min_used_length = $mink;
		my $max_used_length = $maxk;


		# If we're saving this we need to calculate the full range
		# we'll ever use - even if we're not using it this time.
		if ($save_background) {
				$min_used_length = 1;
				$max_used_length = 3;
		}


		my %kmer_counts;
		my %counts_per_length;

		my @letters = qw(G A T C);

		for my $kmer ($min_used_length..$max_used_length) {
#				warn "Looking at kmer length $kmer\n";
				my @kmers = @letters;
				for (0..($kmer-2)) {
						my @expanded;
						foreach my $existing (@kmers) {
								foreach my $letter (@letters) {
										push @expanded,"$existing$letter";
								}
						}
						@kmers = @expanded;
				}

				foreach my $kmer (@kmers) {
						$kmer_counts{$kmer} = 0;
				}
		}


		# Now we can read the file and calculate the frequencies
		# of the kmers within it

		open (my $SEQ,$file) or die "Can't read sequence file '$file': $!";

		my $seq;
		while (<$SEQ>) {
				s/[\r\n\s]//g;
				if (/^>/) {
						# We're at the start of a new sequence
						if ($seq) {
								my %k = get_observed_kmers($seq,$min_used_length,$max_used_length);

								foreach my $kmer (keys %k) {
										if (exists $kmer_counts{$kmer}) {
												$kmer_counts{$kmer} += $k{$kmer};
												$counts_per_length{length($kmer)} += $k{$kmer};
										}
								}
								$seq = "";
						}
				}
				else {
						$seq .= $_;
				}
		}

		close $SEQ;

		# Process the last sequence
		my %k = get_observed_kmers($seq,$min_used_length,$max_used_length);

		foreach my $kmer (keys %k) {
				if (exists $kmer_counts{$kmer}) {
						$kmer_counts{$kmer} += $k{$kmer};
						$counts_per_length{length($kmer)} += $k{$kmer};
				}
		}

		# Change the absolute values into frequencies

		foreach my $kmer (keys %kmer_counts) {

				$kmer_counts{$kmer} /= $counts_per_length{length($kmer)};

		}

		# Save the file if we need to
		if ($save_background) {
				open (my $BG,'>',$save_background) or die "Can't write to '$save_background': $!";

				foreach my $kmer (sort keys %kmer_counts) {
						print $BG join("\t",$kmer,$kmer_counts{$kmer}),"\n";
				}

		}

		return \%kmer_counts;


}

sub _make_compter_background {

		my ($file) = @_;


		# A compter background file is simply a 2 column delimited file
		# of kmer vs frequency.  We need to keep a record of the range of
		# lengths that we've seen to ensure that we've covered what we
		# need for the analysis.

		my $min_length_seen;
		my $max_length_seen;

		open (my $COM, $file) or die "Can't read '$file': $!";

		my %freqs;

		while (<IN>) {
				s/[\r\n]//g;

				my ($kmer,$freq) = split(/\t/);

				my $length = length($kmer);

				unless (defined $min_length_seen) {
						$min_length_seen = $length;
						$max_length_seen = $length;
				}

				$max_length_seen = $length if ($length > $max_length_seen);
				$min_length_seen = $length if ($length < $min_length_seen);

				if (exists $freqs{$kmer}) {
						die "Duplicate frequency found in '$file' for '$kmer'";
				}

				$freqs{$kmer} = $freq;

		}

		close $COM;

		die "Background provided doesn't cover length '$mink'" if ($min_length_seen > $mink);
		die "Background provided doesn't cover length '$maxk'" if ($max_length_seen < $maxk);

		return \%freqs;
}


sub _make_gc_background {

		my %freqs;

		my @letters = qw(G A T C);

		for my $kmer ($mink..$maxk) {
#				warn "Looking at kmer length $kmer\n";
				my @kmers = @letters;
				for (0..($kmer-2)) {
						my @expanded;
						foreach my $existing (@kmers) {
								foreach my $letter (@letters) {
										push @expanded,"$existing$letter";
								}
						}
						@kmers = @expanded;
				}

				foreach my $kmer (@kmers) {
						my $freq = 1;
						my @letters = split(//,$kmer);
						foreach my $letter (@letters) {
								if ($letter eq 'C' or $letter eq 'G') {
										$freq *= ($gc/2/100);
								}
								else {
										$freq *= ((100-$gc)/2/100);
								}
						}

						$freqs{$kmer} = $freq;

#						warn "Frequency of $kmer is $freq\n";
				}

		}

		return \%freqs;

}




__DATA__

    COMPTER - Comparative visualisation of sequence composition

PURPOSE
-------
Compter is a program which takes in one or more multi-fasta format DNA
sequence files and produces both text and graphical outputs summarising
the contents of the files.  It can be used to look for overall compositional
differences between samples, or to look for compositional sub-groups within
a single sequence set.

USAGE
-----

compter [options] [file1] [file2] [file n]


OPTIONS
-------

-o --outfile

-b --background    Specify the background against which enrichment will be
                   calculated.  The value associated with this can be one 
                   of three different things:

                   1) A (multi) fasta DNA sequence file which will be read
                      to calculate a background.  This can be saved for 
                      future re-use using the --savebg option.

                   2) A pre-calculated background file with a .cmp file 
                      extension which was previously created with the
                      --savebg option.

                   3) A background name. This must match a corresponding
                      file in the "backgrounds" folder of the compter
                      installation.  The name must be supplied without
                      the .cmp extension, so if you specify "human" as
                      the background then a file called "human.cmp" must
                      exist in the backgrounds folder

-g --gc            If no background sequence exists for the analysis you want
                   to perform then you can use a theoretcial background based
                   solely around the GC content of the sequence.

--mink             The minimum length of the kmers to be analysed.  Default 1.
                   Valid values are 1,2 or 3.


--maxk             The maximum length of the kmers to be analysed.  Default 3.
                   Valid values are 1,2 or 3.

--maxseq           The maximum number of sequences to be analysed.  This limits
                   how many sequences from each individual file will be used for
                   the calculation.  It\'s generally not a great idea to put 
                   loads of sequences into this analysis as the graphs will not
		               scale to very large sequence numbers.  Default 1000.

-s --savebg        Specify a file name into which the currently calculated 
                   background will be saved.  Only has any effect when --background
                   is specified with a value which is a (multi) fasta file.

--nograph          Skip the drawing of the heatmap and just calculate the table
                   of results.
